use byteorder::{ByteOrder, LE};
use ndarray::{ArrayView1, ArrayView2};

use crate::errors::*;
use crate::functions::{get_classify_func_type, get_classify_function, ObjFunction};
use crate::gbm::grad_booster::GradBooster;
use crate::model_reader::ModelReader;

struct ModelParam {
    /// global bias
    base_score: f32,
    /// number of features
    num_feature: usize,
    /// number of class, if it is multi-class classification
    num_class: i32,
    /// whether the model itself is saved with pbuffer
    saved_with_pbuffer: i32,
}

impl ModelParam {
    fn read_from<T: ModelReader>(
        base_score: f32,
        num_feature: usize,
        reader: &mut T,
    ) -> Result<ModelParam> {
        let (num_class, saved_with_pbuffer) = (reader.read_i32_le()?, reader.read_i32_le()?);
        let mut reserved = [0i32; 30];
        reader.read_to_i32_buffer(&mut reserved)?;
        return Ok(ModelParam {
            base_score,
            num_feature,
            num_class,
            saved_with_pbuffer,
        });
    }

    fn num_feature(&self) -> usize {
        self.num_feature
    }
}

/// Predicts using the Xgboost model
pub struct Predictor {
    mparam: ModelParam,
    //SparkModelParam sparkModelParam;
    obj_func: ObjFunction,
    gbm: Box<dyn GradBooster + Send>,
}

impl Predictor {
    fn read_model_params<T: ModelReader>(reader: &mut T) -> Result<ModelParam> {
        let mut first4bytes = [0u8; 4];
        let mut next4bytes = [0u8; 4];
        reader.read_exact(&mut first4bytes)?;
        reader.read_exact(&mut next4bytes)?;

        let (base_score, num_feature) = if &first4bytes == b"binf" {
            (LE::read_f32(&next4bytes), reader.read_i32_le()? as usize)
        } else if &first4bytes[..3] == [0x00u8, 0x05, 0x5f] {
            // Model generated by xgboost4j-spark?
            return Err(Error::from_kind(ErrorKind::UnsupportedModelType(
                String::from("xgboost4j-spark"),
            )));
        } else {
            (
                LE::read_f32(&first4bytes),
                LE::read_i32(&next4bytes) as usize,
            )
        };

        return ModelParam::read_from(base_score, num_feature, reader);
    }

    /// Instantiates with the Xgboost model
    pub fn read_from<T: ModelReader>(reader: &mut T) -> Result<Predictor> {
        let mparam = Predictor::read_model_params(reader)?;

        let name_obj = reader.read_u8_vec_len()?;
        let name_gbm = reader.read_u8_vec_len()?;

        let obj_func_type = get_classify_func_type(name_obj)?;
        let obj_func = get_classify_function(obj_func_type);
        let gbm = crate::gbm::grad_booster::load_grad_booster(
            reader,
            name_gbm,
            mparam.saved_with_pbuffer != 0,
        )?;

        return Ok(Predictor {
            mparam,
            obj_func,
            gbm,
        });
    }

    pub fn model_num_feature(&self) -> usize {
        self.mparam.num_feature()
    }

    // fn predict_raw(&self, feat: &F, ntree_limit: usize) -> Vec<f32> {
    //     let mut preds = self.gbm.predict(feat, ntree_limit);
    //     for i in 0..preds.len() {
    //         preds[i] += self.mparam.base_score as f32;
    //     }
    //     preds
    // }

    // /// Generates predictions for given feature vector
    // pub fn predict(&self, feat: &F, output_margin: bool, ntree_limit: usize) -> Vec<f32> {
    //     let preds = self.predict_raw(feat, ntree_limit);

    //     return if !output_margin {
    //         (self.obj_func.vector)(&preds)
    //     } else {
    //         preds
    //     };
    // }

    fn predict_single_raw(&self, feat: ArrayView1<'_, f32>, ntree_limit: usize) -> Result<f32> {
        Ok(self.gbm.predict_single(feat, ntree_limit)? + self.mparam.base_score as f32)
    }

    /// Generates a prediction for given feature vector
    pub fn predict_single(
        &self,
        feat: ArrayView1<'_, f32>,
        output_margin: bool,
        ntree_limit: usize,
    ) -> Result<f32> {
        let pred = self.predict_single_raw(feat, ntree_limit)?;
        return if !output_margin {
            Ok((self.obj_func.scalar)(pred))
        } else {
            Ok(pred)
        };
    }

    // /// Predicts leaf index of each tree.
    // pub fn predict_leaf(&self, feat: &F, ntree_limit: usize) -> Vec<usize> {
    //     self.gbm.predict_leaf(feat, ntree_limit)
    // }

    fn predict_many_raw(
        &self,
        feats: ArrayView2<'_, f32>,
        ntree_limit: usize,
    ) -> Result<Vec<Vec<f32>>> {
        let mut preds = self.gbm.predict_many(feats, ntree_limit)?;
        for rid in 0..preds.len() {
            for pid in 0..preds[rid].len() {
                preds[rid][pid] += self.mparam.base_score as f32;
            }
        }
        Ok(preds)
    }

    pub fn predict_many(
        &self,
        feats: ArrayView2<'_, f32>,
        output_margin: bool,
        ntree_limit: usize,
    ) -> Result<Vec<Vec<f32>>> {
        let preds = self.predict_many_raw(feats, ntree_limit)?;

        if !output_margin {
            Ok(preds
                .into_iter()
                .map(|row| (self.obj_func.vector)(&row))
                .collect())
        } else {
            Ok(preds)
        }
    }
}
